package com.example.io;
//
//public class ReadAndWrite {
//}
/*
这里以read系统调用为例，先看下一个完整输入流程的两个阶段：
        ⚫ 应用程序等待数据准备好。
        ⚫ 从内核缓冲区向用户缓冲区复制数据。
        如果是read一个socket（套接字），那么以上两个阶段的具体处理流程如下：
        ⚫ 第一个阶段，应用程序等待数据通过网络中到达网卡，当所等待的分组到达时，
        数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序
        无感知。
        ⚫ 第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。
        再具体一点，如果是在Java客户端和服务器端之间完成一次socket请求和响应（包括
        read和write）的数据交换，其完整的流程如下：
        ⚫ 客户端发送请求：Java客户端程序通过write系统调用，将数据复制到内核缓冲
        区，Linux将内核缓冲区的请求数据通过客户端器的网卡发送出去。在服务端，这
        份请求数据会从接收网卡中读取到服务端机器的内核缓冲区。
        ⚫ 服务端获取请求：Java服务端程序通过read系统调用，从Linux内核缓冲区读取数
        据，再送入Java进程缓冲区。
        ⚫ 服务器端业务处理：Java服务器在自己的用户空间中，完成客户端的请求所对应
        的业务处理。
        ⚫ 服务器端返回数据：Java服务器完成处理后，构建好的响应数据，将这些数据从
        用户缓冲区写入内核缓冲区，这里用到的是write系统调用，操作系统会负责将内
        核缓冲区的数据发送出去。
        ⚫ 发送给客户端：服务端Linux系统将内核缓冲区中的数据写入网卡，网卡通过底层
        的通信协议，会将数据发送给目标客户端。*/
